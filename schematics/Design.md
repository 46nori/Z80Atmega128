# Z80-ATmega128 Board
## ハードウェア
- Z80A 4MHz (以下Z80と呼称)
- 共有メモリ 64KB (256Kbit SRAM x 2)
- AVR ATmega128 16MHz (以下AVRと呼称)
   - Z80のI/Oサブシステムとして使用
   - 2CH シリアルインターフェース
   - SPI接続のmicroSD Cardインターフェース

## 基本方針
- Z80上でCP/M 2.2をネイティブ動作させる。
- ROMは書き込みが面倒なので使用しない。
- SRAMをAVRとZ80で共有する。
- Z80のブートストラップコードは、AVRが事前にSRAM上に配置する。AVRからリセット信号を送ることでZ80を起動させる。
- SRAM以外のZ80の周辺I/OデバイスはAVRでエミュレートする。

## 電源
外部から5Vを供給する。
microSD Cardインターフェースは、5Vから三端子レギュレータで生成した3.3Vを使用する。それ以外はすべて5Vで動作する。

## CPUクロック
### Z80
Z80Aのクロック規定は以下。
 |$\phi$||Min|Max|
 |-|-|-|-|
 |Lowレベル|$V_{ILC}$|$0.3V$|$0.45V$|
 |Highレベル|$V_{IHC}$|$V_{CC}-0.6=4.4V$|$V_{CC}+0.3=5.3V$|
 |周期|$t_C$|$250ns$|$t_{W(\phi H)}+t_{W(\phi L)}+t_r+t_f$|
 |Highパルス幅|$t_{W(\phi H)}$|$110ns$||
 |Lowパルス幅|$t_{W(\phi L)}$|$110ns$|$2000ns$|
 |立ち上がり, 立ち下がり|$t_r$, $t_f$||$30ns$|

8MHzのコルピッツ発振器をD-FF(74HC74)で2分周したDuty 50%の $\phi=4MHz$のクロックが供給される。
  ![4MHz Masterclock](Fig/4MHzClock.png)

### AVR
セラロックで16MHzのクロックを供給する。  
有効にするにはFuseの変更が必要。詳細は[Fuse Bits](#fuse-bits)を参照。

## リセット回路
- $C=1\mu F, R=10K\Omega, 時定数10ms$ のCR積分回路で構成される。
- リセット信号の電圧 $v$と、時間 $t$の関係式は以下。
 $v(t) = V_{cc}(1-e^{-t/CR}), V_{cc} = 5.0$
- リセットに必要な最小パルス幅は以下。
  - AVR: $1.5\mu s (t_{RST})$
  - Z80: $0.75ns$ (3 CLK@4MHz)
  - AVR、Z80が認識するHighレベルの最小値は、それぞれ2.7V以上、2.0V以上である。  
    変形した式 $t(v) = -10.0*10^{-3} \log_e (1-v/5.0)$ から、信号がHighレベルに達するまでの時間を計算すると以下になる。C,Rの誤差を考慮しても、十分な最小パルス幅を満たしている。  
    $t(2.7)=7.8ms >> 1.5\mu s$  
    $t(2.0)=5.1ms >> 0.75ns$

- パワーオン時にはZ80, AVRの両方にリセット信号が供給される。
- AVRはPG4出力で、Z80だけにソフトウェア的にリセットをかけることができる。
- AVRがISPによる制御モード下にある場合、リセット信号はLowのまま保持される。これはZ80側にも供給される。また、[ISP接続時のReset Lineのプルアップ抵抗の制限](https://onlinedocs.microchip.com/pr/GUID-BEB648AA-8539-418A-9EFB-118BDC9DC77B-en-US-1/index.html?GUID-28E6AE85-17D2-45FA-A3CC-FE1B4DC3E00F)により、R>4.7Kにする必要がある。

## Z80出力信号のプルアップ
本回路は全て $V_{cc}=5V$ で動作させている。Z80はTTL出力なので、CMOS標準ロジックIC入力のHレベルと合致しない。Z80からCOMSへの入力信号には基本プルアップが必要である。
| I/O |Level |  TTL |  CMOS (@5.0V)     |
| --- | ---- | -----| ----------------- |
| In  | High | >2.0 |  >0.35 (=0.7x5.0) |
| In  | Low  | <0.8 |  <1.0  (=0.2x5.0) |
| Out | High | >2.4 |  >4.2  (=5.0-0.8) |
| Out | Low  | <0.4 |  <0.4             |

AVRがバスマスタのとき、/BUSACKはLowになり、Z80のほぼ全ての入出力信号はハイインピーダンスになる。/RD, /WR, /MREQ, /IORQ, /M1は標準ロジックICに接続されており、入力が不定にならないようプルアップが必要である。

## DMA
SRAMはZ80とAVRで共有されている。AVRがSRAMアクセスを行いたい場合、すなわちDMA(Direct Memory Access)を行う場合、バスの排他が必要になる。本回路では、Z80の/BUSRQと/BUSACKでそれを実現している。  
AVRがDMAを行う場合、はじめにZ80に対し/BUSRQをLowにして使用権を要求する。Z80は/BUSACKをLにすることでパスの使用権をAVRに委譲する。このときZ80の入出力信号はハイインピーダンスになる。AVRはバスの使用が完了したら/BUSRQをHighにし、バスの使用権をZ80に戻す。

## バスの排他制御
AVRはDMAだけでなくI/Oデバイスのエミュレーションも行うため、Z80とバスの信号が競合しないよう、物理的な排他処理が必要である。

### データバス
図に示すように、AVRとZ80のデータバス接続の排他制御には74HC574と74HC245を使用する。

AVRがDMAを行う場合、すなわちZ80の/BUSACK=Lowの期間は、Z80の制御信号はハイインピーダンスになる。これらはプルアップされているため、74HC574と74HC245の/OE=Highとなり、データバスはZ80から切り離される。

Z80のI/O READと割り込み時は、それぞれI/Oデータと割り込みベクターのラッチが必要なため、74HC574を使用する。ラッチのタイミングは、WAIT生成回路の生成する/WAIT信号の立ち上がりである。

Z80のメモリアクセス時は、74HC245のゲートが開くので、Z80とSRAMのデータバスが直結する。AVR側のPortAはハイインピーダンスにしておかなければならない。
 
![fig](Fig/DataBusExControl.drawio.svg)

### アドレスバス
下位アドレス(A0-7)は、74AC573で排他制御を行う。
AVRがDMAを行う場合は/OE=/BUSACK=Lowなので74AC573のゲートが開き、そのラッチ出力がSRAMの下位アドレスに直結する。このときZ80のアドレスバスはハイインピーダンスである。
一方、Z80がバス使用中は、ゲートが閉じ74AC573の出力はハイインピーダンスとなる。
Z80のI/Oアクセスで、AVRはI/OアドレスのリードするためにPortFを使用する。PortFは通常はハイインピーダンスにセットされている。INT0(/IORD), INT1(/IOWR)による割り込みがAVRにかかると、割り込みハンドラ内で入力にセットしてアドレスのリードし、再びハイインピーダンスに戻す。

上位アドレス(A8-15)は、74HC244で排他制御を行う。
AVRがDMAを行う場合は/OE1=/OE2=/BUSACK=Lowなので74HC244のゲートが開き、PortC出力とSRAMの上位アドレスが直結する。このときZ80のアドレスバスはハイインピーダンスである。
一方、Z80がバス使用中は、ゲートが閉じ74HC244の出力はハイインピーダンスとなる。

![fig](Fig/AddressBusExControl.drawio.svg)


## Z80のI/Oアクセス
00H-7FHのI/O空間は、AVRに接続され、仮想デバイスとしてソフトウェアエミュレーションが行われる。  
このI/O空間へのアクセスが発生すると、AVRに割り込みがかかる。同時にWAIT生成回路によってZ80のI/Oサイクルにウエイトが強制的に挿入される。AVRは割り込みハンドラでデータ入出力を行い、ウエイトを解除することでZ80のI/O操作を完了させる。

### WAIT生成回路
Z80のI/Oサイクルでは/IOREQがアクティブになってから2.5クロック程度で、また割り込みサイクルでは1.5クロック程度で、アドレスバスとデータバスのアクセスを完了させる必要がある。
I/Oサイクルでは1つのTw* が、割り込みサイクルでは2つのTw* が自動的に挿入される。しかし、AVRのソフトウェア処理でを完結させるには不十分なので、ハードウェア的に追加のTwを挿入してAVRでの処理時間を確保する。

/WAITは、I/Oサイクル(/IORQ=Low)、または割り込みサイクル(/IORQ=Lowかつ/M1=Low)を検出したら、次のマスタークロックの立ち上がりでLowになる。
AVRが/RELWAITに5ns以上のLowパルスを出力し、D-FFをリセットするまでこれは保持される。

| $t_{pHL}$| typ  | max   | 電圧/温度 |
| -------- | ---- | ----- | -------- |
| 74HC32   |  8ns |  18ns | 4.5V/25℃ |
| 74AC32   |  5ns |   7ns |   5V/25℃ |

| $t_{pHL}$ / $t_{pLH}$| typ  | max   | 電圧/温度 |
| -------- | ---- | ----- | -------- |
| 74HC74   | 17ns | 44ns | 4.5V/25℃ |
| 74AC74   |  6ns | 10ns |   5V/25℃ |

| $t_{pHL}$| typ  | max   | 電圧/温度 |
| -------- | ---- | ----- | -------- |
| 74HC574  | 17ns |  30ns | 4.5V/25℃ |
| 74AC574  |  5ns | 9.5ns |   5V/25℃ |


## Z80のI/O WRITE
AVRには/IOWRによるINT1割り込みが発生する。割り込みハンドラでは以下の処理を行う。

1. PortFでアドレスバス(A0-A7)の値(I/Oアドレス)をリードする。(PortFは入力にセットされている前提。)
2. PortAを入力にセットする。
3. PortAからI/Oデータをリードする。
4. PortAをハイインピーダンスにセットする。
5. /RELWAITにLowパルスを出力する。

割り込み発生時には、74HC244はZ80→AVR方向の出力が有効なので、アドレスもデータもリード可能な状態になっている。5.で/WAITが解除されると、Z80のI/Oサイクルが完了する。
![fig](Fig/IO-WRITE.svg)

## Z80のI/O READ
AVRには/IORDによるINT0割り込みが発生する。割り込みハンドラでは以下の処理を行う。

1. PortFでアドレスバス(A0-A7)の値(I/Oアドレス)をリードする。(PortFは入力にセットされている前提。)
2. PortAを出力にセットする。
3. PortAにI/Oデータをライトする。
4. /RELWAITにLowパルスを出力する。
5. PortAをハイインピーダンスにセットする。

4.でWAIT生成回路が解除されると、/WAITの立ち上がりで、74HC574が3.のデータをラッチする。このデータはZ80のT3サイクルの立ち下がりでリードされる。/IORDがLowの期間は74HC574の/OEが有効なため、PORTAへのデータ出力の前後のデータがバスに乗ってしまうが、Z80のリードのタイミングまでには正しいデータが確定しているので問題はない。　　

5.でPoartAをハイインピーダンスにするタイミングはデータラッチ以後であることが必要。このため割り込みハンドラ内で適切な時間調整が必要になるかもしれない。

データのラッチは、Twの立ち下がりからT3の立ち下がりまでの時間。以下の合計が250ns以内でなければならない。 $t_{pLH} < 200ns$ を満たせば十分なので、74HC574を使用している。
 - Twの立ち上がりからラッチまでの遅延: $t_{pLH}$
 - /RDのセットアップ時間 : $T_{s\bar{\phi}(D)} = 50ns$


![fig](Fig/IO-READ.svg)

## Z80への割り込み
Z80の割り込みは、Mode2のみサポートする。
CP/Mでは00H-FFHをワークエリアとして予約しているので、Mode1およびNMIは使用できない。

Z80の割り込みサイクルでも、強制ウエイトを挿入する。/IORQはTw* の立ち下がりと同時にLowになる。これはI/Oサイクルのときよりも半クロック遅く、/WAIT生成のラッチタイミングまでのマージンは125nsしかないが、以下の合計がこれに収まっているため問題ない。
- /IORQの $t_{DL\bar{\phi}(IR)}=85ns$
- /WAIT生成回路のD-FF前のORゲート(74HC32)の $t_{pHL}=18ns$

AVRからZ80に割り込みをかける手順は以下。

1. /XINTにLを出力し、Z80に割り込みをかける。
2. /INTRQでAVRにINT4割り込みがかかるので、割り込みハンドラ内で以下を実行。
3. /XINTをHighに戻す。
4. PORTAに割り込みベクターを出力する。
5. /RELWAITにLowパルスを出力する。

Z80の/INTをLowにすると、割り込みサイクルが起動する。/IORQと/M1がLowになるので、74HC574のゲートが開く。同時にAVRに割り込みがかかる。
上記の通りZ80には強制ウエイトがかかっているので、割り込みハンドラ内で4,5を実施する。5.のタイミングで74HC574が割り込みベクターをラッチする。Z80はT3の立ち上がりで割り込みベクターをリードする。

ラッチ動作は割り込みサイクルの最終のTwの立ち下がりで行われるのがワーストケース。下記の合計が125ns以内ならば問題ない。
- 74HC574の $t_{pHL}/t_{pHL} = 44ns$
- Z80の $t_{s\phi(D)} > 35ns$

![fig](Fig/INTERRUPT.svg)

## Z80とSRAMのインターフェース
Z80のメモリアクセスで一番厳しいタイミングはM1サイクルなので、このリードタイミングついて評価すれば十分。

M1サイクルでのデータはT3の立ち上がりでリードされる。このため以下のタイミングを満たすSRAMが必要となる。  
- $t_{OE} < 375ns - (t_{DL\bar{\phi}(RD)} + t_{S\bar{\phi}(D)}) = 245ns$
- $t_{AA} < 500ns - (t_{D(AD)} + t_{S\bar{\phi}(D)}) = 355ns$

HM62256は最も遅い品種でも $t_{OE}=70ns$, $t_{AA}=150ns$ なので、どれを使用しても問題ない。

![fig](Fig/Z80-M1.drawio.svg)
- (1) Z80AのT1の立ち上がりからアドレスが確定するまでの最大時間 : $t_{D(AD)} = 110ns$
- (2) Z80Aの/MREQ,/RDの立ち下がりのどちらか遅い方(/RD) : $t_{DL\bar{\phi}(RD)} = 95ns$ 
- (3) Z80Aのデータのセットアップ時間 : $t_{S\bar{\phi}(D)} = 35ns$
- (4) SRAMの/OEからDataが出力されるまでの最大時間 : $t_{OE}$
- (5) SRAMのアドレスアクセス時間 : $t_{AA}$

## AVRとSRAMのインターフェース
AVRのPortA(PA0-7)は、SRAMのアドレスバスの下位8bitおよび、データバスに接続される。PortC(PC0-7)はアドレスバスの上位8bitに接続されている。

![fig](Fig/AVR-SRAM-RW.drawio.svg)

### XMEMインターフェース
AVRの外部メモリアクセスでは、XMEMインターフェースによりPortAに下位アドレスとデータが時分割で切り替えて出力される。はじめに下位アドレス(A0-7)、次にデータが出力されるので、トランスペアレントラッチ(74AC573)でA0-7を保持しておく必要がある。ラッチはALE(PG2)がLowのタイミングで行う。

AVRのA0-7のアドレスのタイミング特性はALEの立ち下がりに対し以下となっている。
- セットアップ時間 : $t_{AVLL} = 0.5 * t_{CLCL} - 10 = 21.25ns$
- ホールド時間 : $t_{LLAX,ST} = 5ns$
- $t_{CLCL} = 1/16MHz = 62.5ns$

ラッチのホールド時間 $t_h < t_{LLAX,ST}$ を満たさなければならない。74HC573では間に合わないので、高速な74AC573を使用する。ラッチ入力から出力までの伝播遅延時間があるため、アドレス(A0-7)は $t_{pHL} = 10ns$ 分だけ遅れて出力される。

* 74AC573 @ 5.0V/25℃
  |                | min  |  typ  |  max  |
  | -------------- | ---- | ----- | ----- |
  | $t_{pHL}$ (D-Q)|      | 4.5ns |  10ns |
  | $t_s$          |  4ns |       |       |
  | $t_h$          |  4ns |       |       |

* 74HC573 @ 4.5V/25℃
  |                | min  |  typ  |  max  |
  | -------------- | ---- | ----- | ----- |
  | $t_{pHL}$ (D-Q)|      | 14ns  |  22ns |
  | $t_s$          | 10ns |       |       |
  | $t_h$          |  5ns |       |       |

/WR (PG0), /RD (PG1)は、Z80との排他用スリーステートバッファ(74HC125)を通るため、伝播遅延時間 $t_{pHL} = 18ns$ だけ遅れて出力される。

* 74HC125 @ 4.5V/25℃
  |                    | typ  | max  |
  | ------------------ | ---- | ---- |
  | $t_{pHL}, t_{pLH}$ | 11ns | 18ns |

### READ
SRAMのアクセスタイムにより、AVR側のWAIT設定の考慮が必要となる。

WAITを0/1/2で変化させた結果が以下。  
$t_{LLRL}$には74HC125の伝播遅延時間 $t_{pHL}=18ns$(max)が、 $t_{AA}$には74AC573の伝播遅延時間 $t_{pHL}=10ns$(max) 追加されることに注意。

- $t_{LLRL} = 0.5 * t_{CLCL} - 15 ＋ 18 = 34.25ns$
- $t_{DVRH} = 40ns$
- $t_{pHL} = 10ns$ (74AC573の伝播遅延時間)

* 0 WAITの場合
  - $t_{RLRH} = 1.0 * t_{CLCL} - 10 = 52.5ns$
  - $t_{AA} < t_{LLRL} + t_{RLRH} - t_{DVRH} - t_{pHL} = 36.75ns$
  - $t_{OE} < t_{RLDV} = 1.0 * t_{CLCL} - 50 = 12.5ns $

* 1 WAITの場合
  - $t_{RLRH} = 2.0 * t_{CLCL} - 10 = 115ns$
  - $t_{AA} < t_{LLRL} + t_{RLRH} - t_{DVRH} - t_{pHL} = 96.25ns$
  - $t_{OE} < t_{RLDV} = 2.0 * t_{CLCL} - 50 = 75ns$

* 2 WAITの場合
  - $t_{RLRH} = 3.0 * t_{CLCL} - 10 = 177.5ns$
  - $t_{AA} < t_{LLRL} + t_{RLRH} - t_{DVRH} - t_{pHL} = 161.75ns$
  - $t_{OE} < t_{RLDV} = 3.0 * t_{CLCL} - 50 = 137.5ns$

$t_{AA}$と $t_{OE}$を満たすSRAMを選択し、それに応じたXMEMインターフェースのWAIT設定を行う必要がある。  
以下にSRAM(HM62256)の品種と必要なWAITの関係を示す。
|             | $t_{AA}$ | $t_{OE}$ | WAIT |
| ----------- | ---------| -------- | ---- |
| HM62256B-5  |    55ns  |   30ns   |   1  |
| HM62256B-7  |    70ns  |   40ns   |   1  |
| HM62256B-8  |    85ns  |   45ns   |   1  |
| HM62256A-8  |    85ns  |   45ns   |   1  |
| HM62256A-10 |   100ns  |   50ns   |   2  |
| HM62256A-12 |   120ns  |   60ns   |   2  |
| HM62256A-15 |   150ns  |   70ns   |   2  |

### WRITE
WRITEはタイミングに余裕があり、どの型番の組み合わせでも問題ない。
SRAMの型番はREADのタイミング制約に合わせて決めればよい。

* 1 WAITの場合
  - データのセットアップ時間 : $t_{DW} < t_{WHDX} = 2.0 * t_{CLCL} = 125ns$
  - データのホールド時間 : $t_{DH} < t_{WHDX} = 1.0 * t_{CLCL} - 15 = 52.5ns$
  - /WEのパルス幅 : $t_{WP} < t_{WLWH} = 2.0 * t_{CLCL} - 10 = 115.5ns$

* 2 WAITの場合
  - データのセットアップ時間 : $t_{DW} < t_{WHDX} = 3.0 * t_{CLCL} = 187.5ns$
  - データのホールド時間 : $t_{DH} < t_{WHDX} = 1.0 * t_{CLCL} - 15 = 52.5ns$
  - /WEのパルス幅 : $t_{WP} < t_{WLWH} = 3.0 * t_{CLCL} - 10 = 177.5ns$

|             | $t_{DW}$ | $t_{DH}$ | $t_{WP}$ |
| ----------- | ---------| -------- | -------- |
| HM62256B-5  |    25ns  |    0ns   |   35ns   |
| HM62256B-7  |    30ns  |    0ns   |   50ns   |
| HM62256B-8  |    35ns  |    0ns   |   55ns   |
| HM62256A-8  |    40ns  |    0ns   |   55ns   |
| HM62256A-10 |    40ns  |    0ns   |   60ns   |
| HM62256A-12 |    50ns  |    0ns   |   70ns   |
| HM62256A-15 |    60ns  |    0ns   |   90ns   |


## AVRの設定
### Fuse Bits
* デフォルトのATmega103互換モードを解除する。互換モードが有効だと、外部メモリアクセスなどのATmega128の機能が制限されてしまうため。
    | Extended Fuse Byte | bit | Value |
    |--------------------|-----|-------|
    | M103C              |  1  |   1   |

* クロックを外部接続のセラロック16MHzで与えているので以下のように変更する。
    | Fuse High Byte | bit | Value |
    |----------------|-----|-------|
    | CKOPT          |  4  |   0   |

    | Fuse Low Byte | bit | Value |
    |---------------|-----|-------|
    | SUT1          |  5  |   0   |
    | SUT0          |  4  |   0   |
    | CKSEL3-1      | 3-1 |  111  |
    | CKSEL0        |  0  |   1   |

* 最終的な値は以下となる。上記以外のbitの設定はデフォルトのままである。  
  値の変更はMicrochip StudioのDevice ProgrammingメニューからISP経由で行える。
    |                    |  Value  |(Default)|
    |--------------------|---------|---------|
    | Extended Fuse Byte |  0xFF   | (0xFD)  |
    | Fuse High Byte     |  0x89   | (0x99)  |
    | Fuse Low  Byte     |  0xCF   | (0xE1)  |

### IO Port
#### PortA
PA0-7はデフォルトでハイインピーダンスにセットしておく。
* AVRがDMAを行うとき  
  XMEMインターフェースを有効にすることで出力にセットされる。下位アドレス(A0-7)出力、およびデータ(D0-7)出力として使用される。DMAが完了したらハイインピーダンスに戻す。
* Z80のI/O READのとき  
  AVRに/INT0割り込みがかかるので、割り込みハンドラ内で出力にセットし、I/Oデータをライトする。完了したらハイインピーダンスに戻す。
* Z80のI/O WRITEのとき  
  AVRに/INT1割り込みがかかるので、割り込みハンドラ内で入力にセットし、I/Oデータをリードする。完了したらハイインピーダンスに戻す。

#### PortB
* PB0 (/SS)  
  汎用SPIの/SSとして使用する。microSD Cardの/CSに接続する。
* PB1 (SCK)  
  SPI Programming InterfaceのSCK、および汎用SPIのSCKとして使用する。両者は74HC125のスリーステートゲートで排他制御される。リセット信号がHighの時には汎用SPIのSCKが選択される。
* PB2 (MOSI)  
  汎用SPIのMOSIとして使用する。microSD CardのCMDに接続する。
* PB3 (MISO)  
  汎用SPIのMISOとして使用する。microSD CardのDATに接続する。
* PB4  
  常に入力にセットする。LowでmicroSD Cardが挿入されている。
* PB5  
  未使用
* PB6  
  未使用
* PB7  
  未使用


#### PortC
PC0-7は常に出力にセットしておく。  
AVRがDMAを行うとき、XMEMインターフェース機能により上位アドレス(A8-15)出力として使用される。

#### PortD
* PD0 (/INT0)  
  Z80のI/O READ要求時のAVRへの割り込み信号。
* PD1 (/INT1)  
  Z80のI/O WRITE要求時のAVRへの割り込み信号。
* PD2 (RXD1)  
  UART CH1受信として使用
* PD3 (TXD1)  
  UART CH1送信として使用
* PD4  
  常に出力にセットする。  
  Z80への/INT出力。Lowパルス生成でZ80に割り込みをかける。
* PD5  
  常に出力にセットする。  
  /WAIT生成回路のリセット用。Lowパルス生成で/WAIT信号が解除される。
* PD6  
  常に出力にセットする。  
  Z80への/BUSRQ出力。DMA要求時にLowレベルにホールドする。DMA完了時にはHighレベルに戻す。
* PD7  
  常に入力にセットする。  
  Z80の/BASACKをモニタ可能。

#### PortE
* PE0 (RXD0/MOSI)  
  UART CH0受信、およびSPI Programming InterfaceのMOSIとして使用する。両者は74HC125のスリーステートゲートで排他制御される。リセット信号がHighの時にはRXD0が選択される。
* PE1 (TXD0/MISO)  
  UART CH0送信、およびSPI Programming InterfaceのMOSIとして使用する。両者は74HC125のスリーステートゲートで排他制御される。リセット信号がHighの時にはTXD0が選択される。
* PE4 (/INT4)  
  PD4出力でZ80へ割り込み要求をかけると、Z80の割り込みサイクルにより生成されるAVRへの割り込み信号。この割り込みハンドラの中で、Z80に対し割り込みベクタを与える。

#### PortF
PF0-7は常に入力にセットしておく。  
Z80のI/Oアクセス時にI/Oアドレスをリードするために使用する。

#### PortG
* PG0  
  XMEMインターフェース有効時、SRAMの/WR信号として機能する。  
  XMEMインターフェース無効時は、H出力にセットする。  
* PG1  
  XMEMインターフェース有効時、SRAMの/RD信号として機能する。  
  XMEMインターフェース無効時は、H出力にセットする。  
* PG2  
  XMEMインターフェース有効時、74AC573のアドレスラッチ信号として機能する。  
  XMEMインターフェース無効時は、H出力にセットする。  
* PG3  
  未使用  
* PG4  
  常に出力にセットする。Z80へのリセットパルス生成用。

### XMEMインターフェース
SRAMアクセスのためにXMEMインターフェースを有効にするには、MCUCRのSRE(bit 7)をセットする。　　
XMEMインターフェースを無効にしたら、Z80側パスとの衝突を防ぐためPORTAをハイインピーダンスにすること。これを保証するため、XMCRBのXMBK(bit 7)は0にセットされている必要がある。

#### SRAMのWAIT設定
XMCRAとMCUCRの設定で制御する。
外部メモリの全領域に対し、一括で1 or 2 WAIT設定を行うには以下のように設定する。
* WAIT設定  
  | Register |  bit      | 1 WAIT | 2 WAIT |
  |----------|-----------|--------|--------|
  | MCUCR    | SRW10 (6) |    1   |    0   |
  | XMCRA    | SRW11 (1) |    0   |    1   |

* 領域設定 ($1100 - $FFFF)  
  | Register |  bit      | Value |
  |----------|-----------|-------|
  | XMCRA    | SLR0  (4) |   0   |
  | XMCRA    | SLR1  (5) |   0   |
  | XMCRA    | SLR2  (6) |   0   |

XMEMインターフェースでは外部RAM空間を2つに分けて、それぞれ異なるWAIT設定を行うことも可能である。本回路では2個の256bit SRAMを使用するので、32KBごとに領域を分割する場合の設定方法を以下に示す。
* WAIT設定  
  | Register |  bit      | 1 WAIT | 2 WAIT |                    |
  |----------|-----------|--------|--------|--------------------|
  | MCUCR    | SRW10 (6) |    1   |    0   |上位領域($8000-$FFFF)|
  | XMCRA    | SRW11 (1) |    0   |    1   |上位領域($8000-$FFFF)|
  | XMCRA    | SRW00 (2) |    1   |    0   |下位領域($1100-$7FFF)|
  | XMCRA    | SRW01 (3) |    0   |    1   |下位領域($1100-$7FFF)|

* 領域設定　（$1100 - $7FFF / $8000 - $FFFF）  
  | Register |  bit      | Value |
  |----------|-----------|-------|
  | XMCRA    | SLR0  (4) |   0   |
  | XMCRA    | SLR1  (5) |   0   |
  | XMCRA    | SLR2  (6) |   1   |

#### $0000-$10FFのアドレス空間へのアクセス
Z80はリセット時に0番地からプログラムを実行するため、AVRはSRAMの$0000にブートストラップコードを配置しておかなければならない。しかしAVRではSRAMは内部メモリの直後に配置されるので、$0000-$10FFの空間に直接アクセスすることができない。この問題は、SRAMのアドレス空間を狭めることで発生するシャドウ効果を利用した間接的なメモリアクセスで回避できる。　　

XMEMインターフェース有効時、PortCはアドレスバスの上位8bitにマップされるが、XMCRBのXMM0/1/2の設定で一部のピンをGPIOとして解放することが可能である。例えばPortCの上位3bitをGPIOとして強制的に0出力させることで、SRAMの$0000-$1FFFをAVRの$2000-$3FFFにマップできる。(サンプルコードは[データシート](https://ww1.microchip.com/downloads/en/DeviceDoc/doc2467.pdf)の"Using all 64 Kbyte Locations of External Memory"を参照。)
